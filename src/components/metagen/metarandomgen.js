import chooser from "random-seed-weighted-chooser";
import SparkMD5 from "spark-md5";
import seedrandom from "seedrandom";

export const metaRandomGen = async (weights, seed, totalGen) => {
  const random = seedrandom(seed);
  let uniqueNames = {};
  let uniqueIndex = {};

  const uniques = [];

  function generateAttributes(predefined) {
    const attributes = {};
    Object.keys(weights).forEach(
      (trait_type) =>
        (attributes[trait_type] =
          predefined.find((attr) => attr.trait_type === trait_type)?.value ||
          chooser.chooseWeightedObject(weights[trait_type], "weight", 1, random()).name)
    );

    let lastAttributes;
    while (JSON.stringify(lastAttributes) !== JSON.stringify(attributes)) {
      lastAttributes = JSON.parse(JSON.stringify(attributes));

      return Object.keys(attributes).map((trait_type) => ({
        trait_type,
        value: attributes[trait_type],
      }));
    }
  }

  const generateMetadata = (attributes, tokenId) => ({
    name: uniqueNames[tokenId - 1] || `NFT #${tokenId}`,
    description: `NFT Generated by DropLet`,
    attributes,
    image: "",
    droplet: "version alpha",
  });

  return new Promise(async (resolve, reject) => {
    const nft = [];
    const nftHashes = [];
    try {
      for (let i = totalGen; i--; ) {
        const attributes = generateAttributes([]);
        const hash = SparkMD5.hash(JSON.stringify(attributes));
        if (nftHashes.includes(hash)) {
          i++;
          continue;
        }
        nftHashes.push(hash);
        nft.push(attributes);
      }

      uniques.forEach((unique) => {
        for (let i = unique.amount; i--; ) {
          let index;
          while (index == null || uniqueNames[index] || uniqueIndex[index]) {
            index = Math.floor(random() * totalGen);
          }

          uniqueNames[index] = unique.name;
          uniqueIndex[index] = true;

          let newUniqueAttributes = unique.fileName
            ? unique.attributes // For pregenerated uniques
            : generateAttributes(unique.attributes); // For forced sets
          let hash = SparkMD5.hash(JSON.stringify(newUniqueAttributes));
          let y = 0;
          while (nftHashes.includes(hash)) {
            y++;
            // let randomiser = Math.floor(random() * random() * totalNFTs);
            newUniqueAttributes = unique.fileName
              ? unique.attributes // For pregenerated uniques
              : generateAttributes(unique.attributes); // For forced sets
            hash = SparkMD5.hash(JSON.stringify(newUniqueAttributes));
            console.log("hash included alr", y, index);
          }

          nftHashes[index] = hash;
          nft[index] = newUniqueAttributes;
        }
      });
      const totalHash = SparkMD5.hash(JSON.stringify(nft));
      console.log("Local: Combined MD5 hash of all generated NFTs:", totalHash);
      const fullMetadata = nft.map((attributes, i) => generateMetadata(attributes, i + 1));
      resolve(fullMetadata);
    } catch (err) {
      reject(err);
    }
  });
};
